<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>WebSocket èˆ‡ Google Earth 3D Tiles æˆªåœ–æ¸¬è©¦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.127/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.127/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }

    #cesiumContainer {
      width: 1920px;
      height: 1080px;
      margin: 0 auto;
      display: block;
      position: relative;
    }

    #infoBox {
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      border: 1px solid rgba(255, 255, 255, 0);
      font-family: Arial, sans-serif;
      color: white;
    }

    #statusBox {
      position: absolute;
      bottom: 10px;
      left: 10px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-family: Arial, sans-serif;
      z-index: 1000;
    }

    #resultBox {
      position: absolute;
      bottom: 10px;
      right: 10px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-family: Arial, sans-serif;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="infoBox">ç­‰å¾…é€£ç·š...</div>
  <div id="statusBox">ç‹€æ…‹ï¼šç­‰å¾…é€£ç·š</div>
  <div id="resultBox">è¨ˆç®—çµæœï¼š-</div>

  <script>
    // âœ… è¨­å®š Cesium Ion token
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGRlNTU0ZC04ZjI3LTQzZTQtYjkzOC0zZDM2Mjg1M2NhMzUiLCJpZCI6MjY5MTM4LCJpYXQiOjE3NDEyNzUwNjV9.4CesGc_KCiQ7CI0-gIIQZv_5a8ilf6yukgoRkXzo2Ag';

    // âœ… åˆå§‹åŒ– Viewerï¼ˆåŠ å…¥ preserveDrawingBufferï¼‰
    const viewer = new Cesium.Viewer("cesiumContainer", {
      timeline: false,
      animation: false,
      sceneModePicker: false,
      baseLayerPicker: false,
      geocoder: Cesium.IonGeocodeProviderType.GOOGLE,
      globe: false,
      contextOptions: {
        preserveDrawingBuffer: true
      }
    });
    viewer.scene.skyAtmosphere.show = true;

    // âœ… å¼·åˆ¶ç•«é¢è§£æåº¦ç‚º 1920x1080ï¼ˆWebGL canvas å°ºå¯¸ï¼‰
    const width = 1920;
    const height = 1080;
    viewer.container.style.width = width + 'px';
    viewer.container.style.height = height + 'px';
    viewer.scene.canvas.width = width;
    viewer.scene.canvas.height = height;
    viewer.resolutionScale = 1.0;
    viewer.scene.requestRender();

    const infoBox = document.getElementById('infoBox');
    const statusBox = document.getElementById('statusBox');
    const resultBox = document.getElementById('resultBox');

    let firstCapture = true;
    let captureWait = 1500;

    // âœ… WebSocket
    let ws;
    function connectWebSocket() {
      if (!ws || ws.readyState === WebSocket.CLOSED) {
        ws = new WebSocket('ws://localhost:8080');

        ws.onopen = () => {
          console.log("âœ… WebSocket é€£ç·šæˆåŠŸ");
          ws.send(JSON.stringify({ identify: "cesium" }));
        };

        ws.onmessage = event => {
          try {
            const data = JSON.parse(event.data);

            if (data.status === "connected") {
              console.log("ä¼ºæœå™¨ç¢ºèªè­˜åˆ¥:", data.message);
              infoBox.innerHTML = `ä¼ºæœå™¨ç¢ºèª: ${data.message}`;
              return;
            }

            if (data.action === "get_cesium_picture") {
              console.log("æ”¶åˆ°è§¸ç™¼è¨Šæ¯: åŸ·è¡Œ get_cesium_picture");
              statusBox.textContent = "ç‹€æ…‹ï¼šCesiumæˆªåœ–";
              infoBox.textContent = "GPSæ–·ç·š";
              captureAndUpload();
              return;
            }

            if (data.action === "send_Coordinates") {
              console.log("æ”¶åˆ°ç›¸æ©Ÿåº§æ¨™è³‡æ–™ï¼Œæ›´æ–°æ”å½±æ©Ÿç•«é¢");
              statusBox.textContent = "ç‹€æ…‹ï¼šæœ‰åº§æ¨™";
              // æ›´æ–° InfoBox é¡¯ç¤ºè³‡è¨Š
              infoBox.innerHTML = `
                åº§æ¨™æ›´æ–°:<br>
                ç¶“åº¦: ${data.longitude.toFixed(5)}<br>
                ç·¯åº¦: ${data.latitude.toFixed(5)}<br>
                é«˜åº¦: ${data.height.toFixed(2)}<br>
                æœå‘: ${data.heading}Â°<br>
                ä¿¯ä»°: ${data.pitch}Â°<br>
                ç¿»æ»¾: ${data.roll}Â°
              `;

              // è¨­å®š Cesium æ”å½±æ©Ÿä½ç½®èˆ‡æ–¹å‘
              viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(
                  data.longitude,
                  data.latitude,
                  data.height
                ),
                orientation: {
                  heading: Cesium.Math.toRadians(data.heading || 0),
                  pitch: Cesium.Math.toRadians(data.pitch || -90),
                  roll: Cesium.Math.toRadians(data.roll || 0)
                }
              });
            }

            if (data.action === "renew_cesium") {
              viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(
                  data.longitude,
                  data.latitude,
                  data.height
                ),
                orientation: {
                  heading: Cesium.Math.toRadians(data.heading || 0),
                  pitch: Cesium.Math.toRadians(data.pitch || -90),
                  roll: Cesium.Math.toRadians(data.roll || 0)
                }
              });

              if (firstCapture) {
                setTimeout(() => {
                  firstCapture = false;
                }, 10000);
              }
            }

            if (data.action === "send_pixel_Coordinates") {
              console.log("âœ… æ”¶åˆ° pixel åº§æ¨™è¦æ±‚ï¼ˆsend_pixel_Coordinatesï¼‰è¨Šæ¯");
              return;
            }

            if (data.action === "top_match_pixels") {
              console.log("âœ… æ”¶åˆ° top_match_pixels è¨Šæ¯");

              const scene = viewer.scene;
              const results = [];

              data.pixels.forEach((pixel, index) => {
                const x = pixel.x;
                const y = pixel.y;
                const screenPosition = new Cesium.Cartesian2(x, y);
                const worldPosition = scene.pickPosition(screenPosition);

                if (Cesium.defined(worldPosition)) {
                  const cartographic = Cesium.Cartographic.fromCartesian(worldPosition);
                  const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                  const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                  const height = cartographic.height;

                  results.push({
                    x,
                    y,
                    longitude,
                    latitude,
                    height
                  });

                  // âœ… å¯è¦–åŒ–æ¨™è¨˜ï¼ˆå¯é¸ï¼‰
                  viewer.entities.add({
                    position: worldPosition,
                    point: {
                      pixelSize: 6,
                      color: Cesium.Color.YELLOW
                    },
                    label: {
                      text: `(${x.toFixed(0)}, ${y.toFixed(0)})`,
                      font: "10pt sans-serif",
                      fillColor: Cesium.Color.WHITE,
                      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                      outlineWidth: 1,
                      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                      pixelOffset: new Cesium.Cartesian2(0, -10)
                    }
                  });

                } else {
                  console.warn(`âš ï¸ ç¬¬ ${index + 1} é» (${x}, ${y}) ç„¡æ³•å–å¾—ä¸–ç•Œåº§æ¨™`);
                }
              });

              console.log("ğŸ“Œ è½‰æ›å®Œæˆçš„ 3D åº§æ¨™ï¼š", results);

              // å‚³å›çµ¦ä¼ºæœå™¨
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                  action: "got_match_world_coordinates",
                  points: results
                }));
              }

              return;
            }

            if (data.action === "status_update") {
              const map = {
                waiting_drone: "ç­‰å¾…ç„¡äººæ©Ÿå›å‚³",
                superglue: "SuperGlue",
                calculation_done: "è¨ˆç®—å®Œæˆ"
              };
              statusBox.textContent = `ç‹€æ…‹ï¼š${map[data.step] || data.step}`;
              if (data.step === "waiting_drone") {
                infoBox.textContent = "GPSæ–·ç·š";
              }
              return;
            }

            if (data.action === "calculation_result") {
              resultBox.innerHTML = `
                ç¶“åº¦: ${data.longitude.toFixed(6)}<br>
                ç·¯åº¦: ${data.latitude.toFixed(6)}<br>
                é«˜åº¦: ${data.height.toFixed(2)}
              `;
              return;
            }

          } catch (error) {
            console.error("è³‡æ–™è§£æéŒ¯èª¤:", error, event.data);
          }
        };

        ws.onerror = error => {
          console.error("âŒ WebSocket éŒ¯èª¤:", error);
          infoBox.innerHTML = "WebSocket é€£ç·šç™¼ç”ŸéŒ¯èª¤";
        };

        ws.onclose = () => {
          console.warn("âš ï¸ WebSocket é—œé–‰ï¼Œ3 ç§’å¾Œé‡æ–°é€£ç·š...");
          infoBox.innerHTML = "WebSocket é€£ç·šå·²é—œé–‰";
          setTimeout(connectWebSocket, 3000);
        };
      }
    }

    // âœ… å•Ÿå‹• WebSocket
    connectWebSocket();

    // âœ… è¼‰å…¥ Google Earth 3D Tiles
    (async () => {
      try {
        const tileset = await Cesium.createGooglePhotorealistic3DTileset({
          onlyUsingWithGoogleGeocoder: true,
        });
        viewer.scene.primitives.add(tileset);
      } catch (error) {
        console.error(`âŒ Error loading 3D Tiles: ${error}`);
      }
    })();

    // âœ… æ“·å–ç•«é¢ä¸¦ä¸Šå‚³
    function captureAndUpload() {
      console.log("é–‹å§‹æˆªåœ–");

      setTimeout(() => {
        viewer.scene.render();
        const canvas = viewer.scene.canvas;
        const dataURL = canvas.toDataURL("image/png");
        console.log("æˆªåœ–å®Œæˆ");

        displayCapturedImage(dataURL);

        // ä¸Šå‚³åœ–ç‰‡åˆ°å¾Œç«¯
        fetch("http://localhost:8081/upload", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ image: dataURL })
        })
        .then(response => response.json())
        .then(data => {
          console.log("ä¸Šå‚³æˆåŠŸ", data);
          statusBox.textContent = "ç‹€æ…‹ï¼šç­‰å¾… SuperGlue";

          if (ws && ws.readyState === WebSocket.OPEN) {
            setTimeout(() => {
              ws.send(JSON.stringify({
                action: "upload_success"
              }));
              console.log("âœ… å·²é€é WebSocket é€šçŸ¥ä¼ºæœå™¨åœ–ç‰‡ä¸Šå‚³å®Œæˆ");
            }, 1500);
          } else {
            console.warn("âš ï¸ WebSocket å°šæœªé€£ç·šï¼Œç„¡æ³•ç™¼é€ä¸Šå‚³æˆåŠŸé€šçŸ¥");
          }
        })
        .catch(error => {
          console.error("ä¸Šå‚³å¤±æ•—", error);
        });
      }, captureWait);
    }

    // âœ… é¡¯ç¤ºé è¦½åœ–ç‰‡
    function displayCapturedImage(dataURL) {
      const img = document.getElementById("screenshotPreview") || document.createElement("img");
      img.id = "screenshotPreview";
      img.src = dataURL;
      img.style.position = "absolute";
      img.style.top = "10px";
      img.style.right = "10px";
      img.style.width = "200px";
      img.style.border = "2px solid red";
      img.style.background = "#fff";
      
      if (!document.getElementById("screenshotPreview")) {
        document.body.appendChild(img);
      }
    }
  </script>
</body>
</html>
